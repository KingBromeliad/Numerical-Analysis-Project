# -*- coding: utf-8 -*-
"""AutomatedTesting.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Iz-B_JqRaABVx9LIixruSWWAvqYvVlCo
"""

dim_kernel = 9
sigma = 3
max_iterations = 8
deviazione = 0.04
PLOT = 'noplot' #plot
EXEC = 'partial' #full
EXPORT = 'true'
lambd = 10.e-5

import numpy as np
import matplotlib.pyplot as plt
from skimage import data, metrics, io
from scipy import signal
from scipy.optimize import minimize
from numpy import fft
import pandas as pd
from google.colab import files
d1 = pd.DataFrame
d2 = pd.DataFrame
d3 = pd.DataFrame
dfimages = [d1,d2,d3]
dfimages_mse = [d1,d2,d3]

#/\____________| LIB |____________/\
def gaussian_kernel(kernlen, sigma): 
    x = np.linspace(- (kernlen // 2), kernlen // 2, kernlen)    
    kern1d = np.exp(- 0.5 * (x**2 / sigma))
    kern2d = np.outer(kern1d, kern1d)
    return kern2d / kern2d.sum()
def psf_fft(k, d, shape): 
    K_p = np.zeros(shape)
    K_p[:d, :d] = k
    p = d // 2
    K_pr = np.roll(np.roll(K_p, -p, 0), -p, 1)

    K_otf = fft.fft2(K_pr)
    return K_otf

def A(x, K): 
  x = fft.fft2(x)
  return np.real(fft.ifft2(K * x)) 

def AT(x, K): 
  x = fft.fft2(x)
  return np.real(fft.ifft2(np.conj(K) * x)) 

#MINIMIZE
def next_step(x,grad):
  alpha=1.1
  rho = 0.5
  c1 = 0.25
  p=-grad
  j=0
  jmax=10
  while ((f(x+alpha*p) > f(x)+c1*alpha*grad.T@p) and j<jmax ):
    alpha= rho*alpha
    j+=1
  if (j>jmax):
    return -1
  else:
    return alpha

def my_minimize(x0,b,step,MAXITERATION,ABSOLUTE_STOP): 

  x=np.zeros((img_n*img_m,MAXITERATION))
  norm_grad_list=np.zeros((img_n*img_m,MAXITERATION))
  function_eval_list=np.zeros((img_n*img_m,MAXITERATION))
  error_list=np.zeros((img_n*img_m,MAXITERATION))

  x_last = x0
  x[:,0] = x_last

  k=0

  function_eval_list[:,k]=f(x_last)
  error_list[:,k]=np.linalg.norm(x_last-b)
  norm_grad_list[:,k]=np.linalg.norm(grad_f(x_last))

  while (np.linalg.norm(grad_f(x_last))>ABSOLUTE_STOP and k < MAXITERATION -1 ):
    k=k+1
    grad = grad_f(x_last)
    step = next_step(x_last,grad)
    if(step==-1):
      print('non convergente')
      return (iteration) 

    x_last=x_last-step*grad
    x[:,k] = x_last
    function_eval_list[:,k]=f(x_last)
    error_list[:,k]=np.linalg.norm(x_last-b)
    norm_grad_list[:,k]=np.linalg.norm(grad_f(x_last))

  function_eval_list = function_eval_list[:,:k+1]
  error_list = error_list[:,:k+1]
  norm_grad_list = norm_grad_list[:,:k+1]
 
  return (x_last,norm_grad_list, function_eval_list, error_list, k)

#\_____________| IMG |_____________/


Y0 = plt.imread('/content/1.png').astype(np.float64)
X0 = Y0[:,:,0]
Y1 = plt.imread('/content/2.png').astype(np.float64)
X1 = Y1[:,:,0]
Y2 = plt.imread('/content/3.png').astype(np.float64)
X2 = Y2[:,:,0]
Y3 = plt.imread('/content/4.png').astype(np.float64)
X3 = Y3[:,:,0]
Y4 = plt.imread('/content/5.png').astype(np.float64)
X4 = Y4[:,:,0]
Y5 = plt.imread('/content/6.png').astype(np.float64)
X5 = Y5[:,:,0]
Y6 = plt.imread('/content/7.png').astype(np.float64)
X6 = Y6[:,:,0]
Y7 = plt.imread('/content/8.png').astype(np.float64)
X7 = Y7[:,:,0]

images= np.array([X0, X1, X2, X3, X4, X5, X6, X7])

images_n = len(images)

ker= np.array([5, 7, 9], dtype=np.int)
sig= np.array([0.5, 1, 1.3])
dev_s= ([0.001, 0.025, 0.05])
lambda_v = [10.e-2, 10.e-3, 10.e-7]

processed_images = np.zeros((images_n,3), dtype=np.ndarray)
psnr_images = np.zeros([images_n,3])
mse_images = np.zeros([images_n,3])

#1
psnr_images_s1 = np.zeros([3,3])
mse_images_s1 = np.zeros([3,3])

#2
psnr_images_s2 = np.zeros([3,3])
mse_images_s2 = np.zeros([3,3])

#3
psnr_images_s3 = np.zeros([3,3])
mse_images_s3 = np.zeros([3,3])

for n in range (0,images_n):
  IMG = n
  X= images[IMG]
  img_n= X.shape[0]
  img_m= X.shape[1]
  #[_____________| IMG BLUR + NOISE |_____________]

  for i in range (0,3):
    lmbd = lambda_v = [1]
    dim_kernel = ker[i]
    sigma = sig[i]
    K = psf_fft(gaussian_kernel(dim_kernel, sigma), dim_kernel, X.shape) 
    dev = dev_s[0]
    noise = np.random.normal(size=X.shape)*dev 
    b_blur = A(X, K) 
    b = b_blur + noise 
    processed_images[IMG, i] = b
    PSNR= metrics.peak_signal_noise_ratio(X, b) 
    MSE = metrics.mean_squared_error(X, b)
    psnr_images[IMG, i]= PSNR
    mse_images[IMG, i]= MSE


  #|__| PLOT |__|
    if PLOT == 'plot':
      plt.figure(figsize=(30,10))
      ax1 = plt.subplot(1, 3, 1)
      ax1.imshow(X, cmap='gray', vmin=0, vmax=1)
      plt.title('Immagine originale')
      ax2 = plt.subplot(1 ,3, 2)
      ax2.imshow(b_blur, cmap='gray', vmin=0, vmax=1)
      plt.title('Immagine con blur')
      ax2 = plt.subplot(1 ,3, 3)
      ax2.imshow(b, cmap='gray', vmin=0, vmax=1)
      plt.title('Immagine corrotta')
      plt.show()

    #\_____________| PUNTO 2 |_____________/
    if EXEC == 'full':  
      def f(x):
        X= x.reshape(img_n, img_m)
        res = np.subtract(A(X,K),b)
        return 0.5 * np.linalg.norm(res)**2

      def df(x):
        X= x.reshape(img_n, img_m)
        res = AT(np.subtract(A(X,K), b), K)
        return res.flatten()

      x0 = np.zeros(img_n*img_m)
      result = minimize(f, x0, method='CG', jac=df, options= {'maxiter' : max_iterations})
      minimized_image1 = result.x.reshape(img_n, img_m)

      PSNR= metrics.peak_signal_noise_ratio(X, minimized_image1)
      MSE = metrics.mean_squared_error(X, minimized_image1)
      psnr_images_s1[IMG, i]= PSNR
      mse_images_s1[IMG, i]= MSE

      #\_____________| PUNTO 3 |_____________/
      l =  lmbd

      def fr(x):
        X= x.reshape(img_n, img_m)
        res = 0.5 * np.linalg.norm(np.subtract(A(X,K),b))**2
        tikhonov = (l/2) * np.linalg.norm(X)**2
        return res + tikhonov


      def dfr(x):
        X= x.reshape(img_n, img_m)
        res = AT(np.subtract(A(X,K), b), K) + l*X
        return res.flatten()

      x0 = np.zeros(img_n*img_m)
      result = minimize(fr, x0, method='CG', jac=dfr, options= {'maxiter' : max_iterations})
      minimized_image2 = result.x.reshape(img_n, img_m)

      PSNR= metrics.peak_signal_noise_ratio(X, minimized_image2)  
      MSE = metrics.mean_squared_error(X, minimized_image2) 
      psnr_images_s2[IMG, i]= PSNR
      mse_images_s2[IMG, i]= MSE

      l =  lmbd
      step=0.1
      MAXITERATIONS=12
      ABSOLUTE_STOP=1.e-5
      x0 = np.ones(img_n*img_m)
      b_m = b.flatten()

      def f(x):
        X= x.reshape(img_n, img_m)
        b= b_m.reshape(img_n, img_m)
        res = 0.5 * np.linalg.norm(np.subtract(A(X,K),b))**2
        tikhonov = (l/2) * np.linalg.norm(X)**2
        return res + tikhonov

      def grad_f(x):
        X= x.reshape(img_n, img_m)
        b= b_m.reshape(img_n, img_m)
        res = AT(np.subtract(A(X,K), b), K) + l*X
        return np.reshape(res, img_n*img_m)

      (x_last,norm_grad_list, function_eval_list, error_list, k)= my_minimize(x0, b_m,step,MAXITERATIONS, ABSOLUTE_STOP)

      minimized_image_my_minimize= x_last.reshape(img_n, img_m)
      PSNR= metrics.peak_signal_noise_ratio(X, minimized_image_my_minimize)  
      MSE = metrics.mean_squared_error(X, minimized_image_my_minimize) 
      psnr_images_s3[IMG, i]= PSNR
      mse_images_s3[IMG, i]= MSE

    #DATA PRINT
    np.set_printoptions(precision=6)

    if PLOT == 'print_u_data':
      dfp = pd.DataFrame(data=psnr_images[IMG, :], index=["5x5", "7x7", '9x9'], columns=['PSNR Corruzione: ' + str(IMG +1)])
      dfm = pd.DataFrame(data=mse_images[IMG, :], index=["5x5", "7x7", '9x9'], columns=['MSE Corruzione: ' + str(IMG +1)])
      print(dfp, '\n', dfm,'\n')


      dfp1 = pd.DataFrame(data=psnr_images_s1[IMG, :], index=["5x5", "7x7", '9x9'], columns=['PSNR Alg. Naive: '+ str(IMG +1)])
      dfm1 = pd.DataFrame(data=mse_images_s1[IMG, :], index=["5x5", "7x7", '9x9'], columns=['MSE Alg. Naive: '+ str(IMG +1)])
      print(dfp1,'\n', dfm1,'\n')

      dfp2 = pd.DataFrame(data=psnr_images_s2[IMG, :], index=["5x5", "7x7", '9x9'], columns=['PSNR Alg. Tikhonov (CG): '+ str(IMG +1)])
      dfm2 = pd.DataFrame(data=mse_images_s2[IMG, :], index=["5x5", "7x7", '9x9'], columns=['MSE Alg. Tikhonov (CG): '+ str(IMG +1)])
      print(dfp2,'\n', dfm2,'\n')

      dfp3 = pd.DataFrame(data=psnr_images_s3[IMG, :], index=["5x5", "7x7", '9x9'], columns=['PSNR Alg. Tikhonov (G): '+ str(IMG +1)])
      dfm3 = pd.DataFrame(data=mse_images_s3[IMG, :], index=["5x5", "7x7", '9x9'], columns=['MSE Alg. Tikhonov (G): '+ str(IMG +1)])
      print(dfp3,'\n', dfm3,'\n')

    pdata = np.ndarray((3,4))
    pdata[:,0]= psnr_images[IMG, :].T
    pdata[:,1]= psnr_images_s1[IMG, :].T
    pdata[:,2]= psnr_images_s2[IMG, :].T
    pdata[:,3]= psnr_images_s3[IMG, :].T
    pdata_mse = np.ndarray((3,4))
    pdata_mse[:,0]= mse_images[IMG, :].T
    pdata_mse[:,1]= mse_images_s1[IMG, :].T
    pdata_mse[:,2]= mse_images_s2[IMG, :].T
    pdata_mse[:,3]= mse_images_s3[IMG, :].T
    dfimages[IMG] = pd.DataFrame(data= pdata, index=['10e-2', '10e-3', '10e-7' ], columns=['PSNR Corruzione', 'PSNR Alg. Naive', 'PSNR Alg. Tikhonov (CG)', 'PSNR Alg. Tikhonov (G)'])
    dfimages_mse[IMG] = pd.DataFrame(data= pdata_mse, index=['10e-2', '10e-3', '10e-7' ], columns=['MSE Corruzione', 'MSE Alg. Naive', 'MSE Alg. Tikhonov (CG)', 'MSE Alg. Tikhonov (G)'])

if EXPORT == 'true':
  np.set_printoptions(precision=6)
  output = pd.concat(dfimages)
  output2 = pd.concat(dfimages_mse)

  output.to_csv('lmbd_psnr.csv')
  files.download('lmbd_psnr.csv')
  output2.to_csv('lmbd_mse.csv')
  files.download('lmbd_mse.csv')

  #|__| PLOT |__|




if PLOT == 'plot_s':
  plt.figure(figsize=(30,10))
  ax2 = plt.subplot(1 ,3, 1)
  ax2.imshow(minimized_image1, cmap='gray', vmin=0, vmax=1)
  plt.title('Deblur naive')
  ax2 = plt.subplot(1 ,3, 2)
  ax2.imshow(minimized_image2, cmap='gray', vmin=0, vmax=1)
  plt.title('Deblur with Tikhonov regularization')
  ax3 = plt.subplot(1 ,3, 3)
  ax3.imshow(minimized_image_my_minimize, cmap='gray', vmin=0, vmax=1)
  plt.title('Deblur using custom minimize')
  plt.show()

  for i in range (0, 3):

    plt.figure(figsize=(20,10))
    plt.suptitle('VALORI KERNEL: {k}x{k} SIGMA: {s} DEVIAZIONE NOISE: {d}'.format(s=sig[i], k=ker[i], d=dev))
    ax1 = plt.subplot(2 ,4, 1)
    ax1.imshow(processed_images[0,i], cmap='gray', vmin=0, vmax=1)
    plt.title('PSNR: {0:.6f}'.format(psnr_images[0,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[0,i]))
    ax2 = plt.subplot(2 ,4, 2)
    ax2.imshow(processed_images[1,i], cmap='gray', vmin=0, vmax=1)
    plt.title('PSNR: {0:.6f}'.format(psnr_images[1,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[1,i]))
    ax3 = plt.subplot(2 ,4, 3)
    ax3.imshow(processed_images[2,i], cmap='gray', vmin=0, vmax=1)
    plt.title('PSNR: {0:.6f}'.format(psnr_images[2,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[2,i]))
    ax4 = plt.subplot(2 ,4, 4)
    ax4.imshow(processed_images[3,i], cmap='gray', vmin=0, vmax=1)
    plt.title( 'PSNR: {0:.6f}'.format(psnr_images[3,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[3,i]))
    ax5 = plt.subplot(2 ,4, 5)
    ax5.imshow(processed_images[4,i], cmap='gray', vmin=0, vmax=1)
    plt.title('PSNR: {0:.6f}'.format(psnr_images[4,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[4,i]))
    ax6 = plt.subplot(2 ,4, 6)
    ax6.imshow(processed_images[5,i], cmap='gray', vmin=0, vmax=1)
    plt.title('PSNR: {0:.6f}'.format(psnr_images[5,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[5,i]))
    ax7 = plt.subplot(2 ,4, 7)
    ax7.imshow(processed_images[6,i], cmap='gray', vmin=0, vmax=1)
    plt.title( 'PSNR: {0:.6f}'.format(psnr_images[6,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[6,i]))
    ax8 = plt.subplot(2 ,4, 8)
    ax8.imshow(processed_images[7,i], cmap='gray', vmin=0, vmax=1)
    plt.title( 'PSNR: {0:.6f}'.format(psnr_images[7,i]) + ' \n'+ 'MSE: {0:.6f}'.format(mse_images[7,i]))

    plt.show()

